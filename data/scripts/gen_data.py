import pickle
from typing import Any
import qiskit as qk
import numpy as np
from tqdm import tqdm
from qaoa import QaoaCircuit
from qiskit.algorithms.optimizers.optimizer import POINT
from qiskit.circuit import QuantumCircuit
import networkx as nx
from rich.progress import track
import itertools
def max_cut_brute_force(G) -> tuple[int, tuple[set, set]]:
    """
    Find the Max-Cut of graph G using brute force.
    
    G: A networkx graph.
    
    Returns:
    - Max cut value
    - A tuple with two sets representing the partition.
    """
    nodes = G.nodes()
    n = G.number_of_nodes()
    max_cut_value = 0
    best_partition = None

    # Iterate over all possible partitions (combinations of nodes)
    for i in range(1, n // 2 + 1):  # Only need to go up to half since the rest are symmetric
        for partition in itertools.combinations(nodes, i):
            set_A = set(partition)
            set_B = set(nodes) - set_A
            
            cut_value = 0
            for u, v in G.edges():
                if (u in set_A and v in set_B) or (u in set_B and v in set_A):
                    cut_value += G[u][v].get('weight', 1)

            if cut_value > max_cut_value:
                max_cut_value = cut_value
                best_partition = (set_A, set_B)

    return max_cut_value, best_partition


def generate_graphs(n_graphs, min_n_nodes, max_n_nodes, p_edge) -> list[nx.Graph]:
    """Generate a list containing random graphs generated by Networkx."""

    datapoints: set[nx.Graph] = set()
    # Generate random graphs until we have enough
    # We use a set to avoid duplicates
    while len(datapoints) < n_graphs:
        n_nodes = np.random.randint(min_n_nodes, max_n_nodes + 1)
        random_graph: nx.Graph = nx.gnp_random_graph(n_nodes, p=p_edge)
        if nx.is_empty(random_graph):
            continue
        for graph in datapoints:
            if nx.is_isomorphic(graph, random_graph):
                continue
        datapoints.add(random_graph)
    return list(datapoints)

def qaoa_from_graph(graph, n_layers=1) -> QaoaCircuit:
    """Generate a QAOA parameterized circuit from a graph."""
    return QaoaCircuit(graph, n_layers)

def generate_qaoa_circuits(graphs, n_layers=1) -> list[QaoaCircuit]:
    """Generate a list of QAOA circuits from a list of graphs."""
    circuits: list[QaoaCircuit] = []
    for graph in graphs:
        if graph.number_of_edges() == 0:
            continue
        circuits.append(qaoa_from_graph(graph, n_layers))
    return circuits

def get_optimial_parameters_from_qaoa(qaoa_circuit: QaoaCircuit, backend=qk.Aer.get_backend("qasm_simulator"), shots=1000, initial_params=None) -> tuple[POINT, float]:
    """Get the optimal parameters for a QAOA circuit."""
    max_cut_val, _ = max_cut_brute_force(qaoa_circuit.graph)
    def objective_function(params) -> float:
        """Objective function for QAOA."""
        beta = params[:qaoa_circuit.n_layers]
        gamma = params[qaoa_circuit.n_layers:]
        params_dict = {qaoa_circuit.beta: beta, qaoa_circuit.gamma: gamma}
        qc = qaoa_circuit.assign_parameters(params_dict)
        job = qk.execute(qc, backend, shots=shots)
        result = job.result()
        counts: dict[str, int] = result.get_counts()
        max_count = max(counts, key=lambda x: counts[x])
        approx_ratio  = - qaoa_circuit.energy_cost(int(max_count, 2)) / max_cut_val
        return -approx_ratio
    from qiskit.algorithms.optimizers import COBYLA
    optimizer = COBYLA(maxiter=10000)
    initial_params = np.random.rand(2 * qaoa_circuit.n_layers) if initial_params is None else initial_params
    bounds = [(0, 2 * np.pi)] * 2 * qaoa_circuit.n_layers
    optimal_params = optimizer.minimize(objective_function, initial_params, bounds=bounds).x
    
    if optimal_params is None:
        raise ValueError("Optimization failed")
    return optimal_params, objective_function(optimal_params)

def check_approx_ratio(qaoa_circuit: QaoaCircuit, params: np.ndarray, backend=qk.Aer.get_backend("qasm_simulator"), shots=1000) -> float:
    """Check the approximation ratio of a QAOA circuit with given parameters."""
    max_cut_val, _ = max_cut_brute_force(qaoa_circuit.graph)
    beta = params[:qaoa_circuit.n_layers]
    gamma = params[qaoa_circuit.n_layers:]
    params_dict = {qaoa_circuit.beta: beta, qaoa_circuit.gamma: gamma}
    qc = qaoa_circuit.assign_parameters(params_dict)
    job = qk.execute(qc, backend, shots=shots)
    result = job.result()
    counts: dict[str, int] = result.get_counts()
    max_count = max(counts, key=lambda x: counts[x])
    approx_ratio  = - qaoa_circuit.energy_cost(int(max_count, 2)) / max_cut_val
    return approx_ratio

def generate_dataset(num_of_graphs: int, min_graph_size: int, max_graph_size: int, p_edge: float, n_layers: int) -> tuple[list[nx.Graph], list[QuantumCircuit], list[float]]:
    """Generate a dataset of graphs and QAOA circuits."""
    graphs = generate_graphs(num_of_graphs, min_graph_size, max_graph_size, p_edge)
    return generate_dataset_from_graphs(graphs, n_layers)

def generate_dataset_from_graphs(graphs: list[nx.Graph], n_layers: int) -> tuple[list[nx.Graph], list[QuantumCircuit], list[float]]:
    print(f"Created {len(graphs)} graphs")
    qaoa_circuits = generate_qaoa_circuits(graphs, n_layers)
    optimal_params = {}
    total_approx_ratio, approx_ratio  = 0, 0
    for graph, qaoa_circuit in track(zip(graphs, qaoa_circuits), description="Optimizing QAOA circuits...", total=len(qaoa_circuits)):
        params = None
        for iters in range(100):
            params, _ = get_optimial_parameters_from_qaoa(qaoa_circuit, initial_params=params)
            approx_ratio = check_approx_ratio(qaoa_circuit, params)
            if approx_ratio > 0.85:
                break
        if approx_ratio < 0.7:
            print(f"Approx ratio is too low: {approx_ratio}")
            continue
        total_approx_ratio += approx_ratio
        print(f"Optimal parameters approx ratio: {approx_ratio}, graph size: {qaoa_circuit.graph.number_of_nodes()}, after {iters} iterations")
        optimal_params[qaoa_circuit.id] = (graph, qaoa_circuit, np.array(params))
    print(f"Average approximation ratio: {total_approx_ratio / len(optimal_params)}")
    graphs, circuits, params = zip(*optimal_params.values())      
    return graphs, circuits, params


def generate_dataset_and_save(
    num_of_graphs: int=500,
    graph_min_size: int=7,
    graph_max_size: int=15,
    p_edge: float=0.5,
    n_layers: int = 5,
):
    graphs, qaoa_circuits, optimal_params = generate_dataset(num_of_graphs, graph_min_size, graph_max_size, p_edge, n_layers)
    num_of_graphs = len(graphs)
    with open(f"data/dataset_G{num_of_graphs}_P{n_layers}_N{graph_min_size}-{graph_max_size}.pkl", "wb") as f:
        pickle.dump((graphs, qaoa_circuits, np.array(optimal_params)), f)
        
def generate_atlas_graphs(n_layers: int):
    graphs: list[nx.Graph] = nx.graph_atlas_g()
    graphs, qaoa_circuits, optimal_params = generate_dataset_from_graphs(graphs, n_layers)
    num_of_graphs = len(graphs)
    with open(f"data/dataset_ATLAS_P{n_layers}_N{num_of_graphs}.pkl", "wb") as f:
        pickle.dump((graphs, qaoa_circuits, np.array(optimal_params)), f)

    
for i in [3,4,5]:
    generate_atlas_graphs(i)

