#%%
import qiskit as qk
import numpy as np
from qaoa import QaoaCircuit
from qiskit.algorithms.optimizers.optimizer import POINT
from qiskit.circuit import QuantumCircuit
import networkx as nx
from rich.progress import track
import itertools
def max_cut_brute_force(G) -> tuple[int, tuple[set, set]]:
    """
    Find the Max-Cut of graph G using brute force.
    
    G: A networkx graph.
    
    Returns:
    - Max cut value
    - A tuple with two sets representing the partition.
    """
    nodes = G.nodes()
    n = G.number_of_nodes()
    max_cut_value = 0
    best_partition = None

    # Iterate over all possible partitions (combinations of nodes)
    for i in range(1, n // 2 + 1):  # Only need to go up to half since the rest are symmetric
        for partition in itertools.combinations(nodes, i):
            set_A = set(partition)
            set_B = set(nodes) - set_A
            
            cut_value = 0
            for u, v in G.edges():
                if (u in set_A and v in set_B) or (u in set_B and v in set_A):
                    cut_value += G[u][v].get('weight', 1)

            if cut_value > max_cut_value:
                max_cut_value = cut_value
                best_partition = (set_A, set_B)

    return max_cut_value, best_partition


def generate_graphs(n_graphs, n_nodes, p_edge) -> list[nx.Graph]:
    """Generate a list containing random graphs generated by Networkx."""

    datapoints: list[nx.Graph] = []
    for _ in range(n_graphs):
        random_graph: nx.Graph = nx.gnp_random_graph(n_nodes, p=p_edge)
        datapoints.append(random_graph)
    return datapoints

def qaoa_from_graph(graph, n_layers=1) -> QaoaCircuit:
    """Generate a QAOA parameterized circuit from a graph."""
    return QaoaCircuit(graph, n_layers)

def generate_qaoa_circuits(graphs, n_layers=1) -> list[QaoaCircuit]:
    """Generate a list of QAOA circuits from a list of graphs."""
    circuits: list[QaoaCircuit] = []
    for graph in graphs:
        circuits.append(qaoa_from_graph(graph, n_layers))
    return circuits

def get_optimial_parameters_from_qaoa(qaoa_circuit: QaoaCircuit, backend=qk.Aer.get_backend("qasm_simulator"), shots=1000) -> tuple[POINT, float]:
    """Get the optimal parameters for a QAOA circuit."""
    max_cut_val, _ = max_cut_brute_force(qaoa_circuit.graph)
    def objective_function(params) -> float:
        """Objective function for QAOA."""
        beta = params[:qaoa_circuit.n_layers]
        gamma = params[qaoa_circuit.n_layers:]
        params_dict = {qaoa_circuit.beta: beta, qaoa_circuit.gamma: gamma}
        qc = qaoa_circuit.assign_parameters(params_dict)
        job = qk.execute(qc, backend, shots=shots)
        result = job.result()
        counts: dict[str, int] = result.get_counts()
        max_count = max(counts, key=lambda x: counts[x])
        approx_ratio  = - qaoa_circuit.energy_cost(int(max_count, 2)) / max_cut_val
        return -approx_ratio
    from qiskit.algorithms.optimizers import COBYLA
    optimizer = COBYLA(maxiter=10000)
    initial_params = np.random.rand(2 * qaoa_circuit.n_layers)
    bounds = [(0, 2 * np.pi)] * 2 * qaoa_circuit.n_layers
    optimal_params = optimizer.minimize(objective_function, initial_params, bounds=bounds).x
    
    if optimal_params is None:
        raise ValueError("Optimization failed")
    return optimal_params, objective_function(optimal_params)

def check_approx_ratio(qaoa_circuit: QaoaCircuit, params: np.ndarray, backend=qk.Aer.get_backend("qasm_simulator"), shots=1000) -> float:
    """Check the approximation ratio of a QAOA circuit with given parameters."""
    max_cut_val, _ = max_cut_brute_force(qaoa_circuit.graph)
    beta = params[:qaoa_circuit.n_layers]
    gamma = params[qaoa_circuit.n_layers:]
    params_dict = {qaoa_circuit.beta: beta, qaoa_circuit.gamma: gamma}
    qc = qaoa_circuit.assign_parameters(params_dict)
    job = qk.execute(qc, backend, shots=shots)
    result = job.result()
    counts: dict[str, int] = result.get_counts()
    max_count = max(counts, key=lambda x: counts[x])
    approx_ratio  = - qaoa_circuit.energy_cost(int(max_count, 2)) / max_cut_val
    return approx_ratio

def generate_dataset(num_of_graphs: int, graph_size: int, p_edge: float, n_layers: int) -> tuple[list[nx.Graph], list[QuantumCircuit], list[float]]:
    """Generate a dataset of graphs and QAOA circuits."""
    graphs = generate_graphs(num_of_graphs, graph_size, p_edge)
    print(f"Created {len(graphs)} graphs")
    qaoa_circuits = generate_qaoa_circuits(graphs, n_layers)
    optimal_params = []
    for qaoa_circuit in track(qaoa_circuits, description="Optimizing QAOA circuits...", total=len(qaoa_circuits)):
        while True:
            params, _ = get_optimial_parameters_from_qaoa(qaoa_circuit)
            approx_ratio = check_approx_ratio(qaoa_circuit, params)
            if approx_ratio > 0.7:
                break
        optimal_params.append(np.array(params))
    return graphs, qaoa_circuits, optimal_params
# %%
import pickle
if __name__ == "__main__":
    num_of_graphs=500
    p_edge=0.5
    for graph_size in [12]:
        for n_layers in [2, 3, 4]:
            graphs, qaoa_circuits, optimal_params = generate_dataset(num_of_graphs, graph_size, p_edge, n_layers)
            with open(f"data/dataset_G{num_of_graphs}_N{graph_size}_P{n_layers}.pkl", "wb") as f:
                pickle.dump((graphs, qaoa_circuits, np.array(optimal_params)), f)
# %%
